#include <iostream>

using namespace std;
///////////
// 指针
///////////

//////
// C++没有字符串数据类型，处理字符串可以使用 数组， 字符指针， string.h库。
// 一定要理解 指针 = 数组；前者是实质，后者是表象
// char* a = "adf"; //定义的时候，char* 可以理解为char类型的指针
// *a; // 间接访问；*为取后面的地址指向的值
// &为取地址符；
//////

void test_range(char t1) 
{
	t1 = 'a';
};
void main_6()
{
	char bb ='s';
	char *c1 = "abc"; //c1是一个char* 类型的指针，指向的内存只能存放char类型的参数
	char c2[] = "abc";
	char *c3 = (char*)malloc(3);
	//只能执行语句1，或者语句23.   
	c3 = "abc";  //语句1   
				 //strcpy(c3,"abc"); //语句2   
				 //c3[0] = 'g'; //语句3   
	char *a = &bb;
	printf(a);
	printf("%d %d %s\n", &c1, c1, c1);
	printf("%d %d %c\n", &c2, c2, c2[0]);
	printf("%d %d %s\n", &c3, c3, c3);

	//char* s1 = "abc";
	char s2[10] = "def";	// 这里的s2数组指针没有存储在内存中，而是在编译器中
	// 这里的10是指预存的大小，而不是第11个字符
	char* s3 = s2;
	//char* s5 = &s2;	// 
	//printf("%d %d %s\n", &s1, s1, s1);
	printf("%d %c %d %s\n", &s2, *s2, s2, s2);	// *s2指s2数组的第一个位置的值；
	printf("%d %c %d %s\n", &s3, *s3, s3, s3);	// 第一个 &s3 得到的是 指针变量的s3的位置
	//@@ cout 类似于 printf("%s", 地址)；
	cout << "s2:" << s2 << endl;	// 
	cout << "s3:" << s3 << endl;
	cout << "&s3[0]:" << &s3[0] << endl;	// &s3[0]指s3[0]的地址
	cout << "&s3:" << &s3 << endl;
	cout << "*s3:" << *s3 << endl;
	cout << "s3[0]:" << s3[0] << endl;
	cout << "&s2:" << &s2 << endl;
	cout << s2[0] << endl;
	cout << s2[1] << endl;
	cout << s2[2] << endl;


	//////////////////////////////////////////////////////////////////////////
	// void类型指针
	void *pv;
	int i = 10;
	pv = &i;
	cout << *static_cast<int*>(pv);	// 如果需要访问内存中的具体数据，需要进行强制类型转换。
	// 除了字符指针外，其他指针可以直接用cout语句来输出地址值，如果想看字符指针所指向的地址，可以强制类型转化为void*
	// 只允许void*和其他类型的指针值进行转换


	//////////////////////////////////////////////////////////////////////////
	// 申请动态空间（通常与指针一起使用），一定记得释放空间
	int* pi;
	pi = new int(10);
	delete pi;	
	// 只申请一个4个字节内存的位置，并存放int类型的数据10
	int* piarray;
	piarray = new int[10];
	delete[]piarray;
	// 内存泄露：指向一个内存空间的指针又指向了另一个内存空间，导致原内存无法释放
	// 指针悬挂：存在指针，但是指向的内存空间被释放了。


	//////////////////////////////////////////////////////////////////////////
	// 指向结构体的指针（结构指针）
	// 访问： ps->score 等价于 (*ps).score； ps是指针，score是结构中的一个元素


	//////////////////////////////////////////////////////////////////////////
	// 引用（是变量或其他编程实体的别名，不能单独定义）
	// 格式： 类型名 &引用名 = 变量名

	
	//////////////////////////////////////////////////////////////////////////
	// 常指针和常引用（直接 *指针名=数值 是不允许的，也就是指针
	//                 所指向的内容不可以通过该指针的见解引用来改变）
	// const <类型名>*<指针名>
	// const <类型名>&<引用名>

	//////////////////////////////////////////////////////////////////////////
	// 指针常量（指针本身的内容是不可以修改的，数组的名称就是一个指针常量）
	// <类型名>*const<指针名>

}